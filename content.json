{"pages":[],"posts":[{"title":"TypeScript函数","text":"签名准备 购买证书或MakeCert.exe和pvk2pfx.exe(生成.pfx的自签名证书) 使用electron-builder构建的Electron项目。 需要有外网环境 自签名只能在本地开发或测试的时候使用，生产环境还是需要购买权威机构的证书。 证书 本地开发可以使用 MakeCert.exe工具创建自签名证书。 12345678910# * -n: 主题名称# * -r : 指定证书将自签名# * -sv: 指定包含私钥容器的文件# 生成 .cer 证书./makecert.exe -n &quot;CN=TempCA&quot; -r -sv TempCA.pvk TempCA.cer# 将 .cer 证书 转换成 .pfx 证书./pvk2pfx.exe -pvk ./TempCA.pvk -spc ./TempCA.cer -pfx ./cert3.pfx 生产环境中 Mac购买开发者证书， windows可以在赛门铁克、WoSign等证书提供商购买证书。 electron-builder签名的时候，会到远程的服务器获取一个时间。所以需要有外网环境。 签名过程中遇到的问题 Can't sign app: The specified timestamp server either could not be reached or returned an invalid response 解决方案： 查看是否有网络。 查看时间戳服务器是否正常工作。查看package.json配置项中 signingHashAlgorithms、rfc3161TimeStampServer、timeStampServer的属性。signingHashAlgorithms的值为sha1就从timeStampServer指定的服务器中获取时间戳。signingHashAlgorithms的值为sha256就从rfc3161TimeStampServer指定的服务器中获取时间戳。 在electron-builder/packages/app-builder-lib/src/codeSign/windowsCodeSign.ts文件有判断。 rfc3161TimeStampServer服务器地址http://tsa.wotrus.com 暂时可用(2020-03-16); 构建成功： 在应用程序启动应用程序的属性中可以看到数字签名一栏：","link":"/2019/11/13/Electron%E6%9E%84%E5%BB%BA%E7%AD%BE%E5%90%8D/"},{"title":"mongodb查询","text":"find find 简介 Mongodb 使用find进行查询。find有两个参数，第一个参数是指定查询条件。默认是 {}。 12// 不指定任何条件，查询所有db.collections.find(); 指定返回的值 find的第二个参数是指定需要返回哪些字段，这样避免将所有的字段返回，可以节省传输的数据量，也可以节省客户端解码文档的时间和内存消耗。指定字段的值 1 为包含， 0 为排除。默认情况下 _id是总是会返回的，只有当设置为 0 才不会返回。指定的字段中不能同时又包含和排除。 格式 1db.collection.find(&lt;查询条件&gt;, &lt;需要返回的字段&gt;) 12// 返回的文档中只包含 `name` 、`email`和`_id`。db.users.find({ name: &quot;A&quot; }, { name: 1, email: 1 }); 12// 返回文档中除 `name`字段外所有的字段。db.users.find({ name: &quot;A&quot; }, { name: 0 }); 12// 下面的查询出错**`Error`**db.users.find({ name: &quot;A&quot; }, { name: 1, email: 0 }); 查询条件 查询条件 $lt、$gt、$lte、$gte是比较操作符，可以单独使用，也可以组合使用查询一个范围的值。可以比较数字型、时间型的值。 12// 查询 18~30岁（含）的用户db.users.find({ age: { $gte: 18, $lte: 30 } }); 12// 查找2007年1月1日之前注册的用户。db.users.find({ registered: { $lt: new Date(&quot;01/01/2007&quot;) } }); $ne是不等操作符。当查询条件需要正则去匹配的时候，使用$ne会出错。正则类型的可以使用 $not操作符。 12// 查找 `name!=A` 的用户。db.users.find({ name: { $ne: &quot;A&quot; } }); 123// 下面查询`name`字段不以`A`开头的用户，报错了。// Error `Can't have regex as arg to $ne.`db.users.find({ name: { $ne: /^A/ } }); OR 查询 有两种方式进行 OR 查询。一种是使用$in用来查询一个键的多个值，一种是使用$or 可以在多个键中查询任意给定的值。如果需要对$in的匹配条件后取反可以使用$nin。 12// 查询 `status`字段的值是 `1`|`2`|`3`的用户db.users.find({ status: { $in: [1, 2, 3] } }); 12// 查询`status`字段的不是 `1`|`2`|`3`的用户db.users.find({ status: { $nin: [1, 2, 3] } }); 12// 查询 `status`字段是`1` 或者 `age`字段大于`18`的用户db.users.find({ $or: [{ status: 1 }, { age: { $gt: 18 } }] }); $not $not操作符是匹配那些不符合条件的文档。相对$ne ，$not可以结合正则表达式一起使用。 123456789// 查询`name`字段不是 A 的文档db.users.find({ name: { $not: &quot;A&quot; } });// 查询`age`字段不小于1的文档db.users.find({ age: { $not: { $lt: 1 } } });// 结合正则表达式查询// 查询 `name`字段不以字符串 a 开头的db.users.find({ name: { $not: /^a/i } }); 条件语句 查询操作符一般是内层文档的键。更新操作符则是外层文档的键。 特定类型查询 null null类型可以匹配自身，还会匹配那些没有这个键的文档。如果要排除掉没有这个键的文档 需要结合$exists这个操作符。 12345// 下面这样会查询出 字段 x 为 null 和那些没有 x 字段的文档db.users.find({ x: null });// 下面只会查询出 字段 x 为 nulldb.users.find({ x: { $in: [null], $exists: true } }); 正则表达式 正则表达式可以灵活有效的匹配字符串。像对一个字段的模糊查询，忽略大小写等待非常有用。正则表达式也可以匹配到自身，如果字段中的值就是一个正则表达式，也能正确匹配。 12345// 查询字段 name 中包含 (a|A) 的文档db.users.find({ name: /a/i });// 查询字段 name 中包含 (a|A) 开头的文档db.users.find({ name: /^a/i }); 查询数组 单个元素匹配数组 123// 假设 fruit 的值一个数组// 下面的匹配会匹配到 fruit 数组中包含 apple 一项的文档db.foods.find({ fruit: &quot;apple&quot; }); 多个元素匹配数组 123// 假设 fruit 的值一个数组// 下面的匹配会匹配到 fruit 数组中包含 apple 和 banana 的文档db.foods.find({ fruit: { $all: [&quot;apple&quot;, &quot;banana&quot;] } }); 数组精确匹配 数组的精确匹配必须 查询条件 和 文档中的值个数和顺序都必须保持一致。要查询数组中特定位置的元素，可加上数组下标进行查询。 1234567// 假设 fruit 的值一个数组// 下面只会匹配字段 fruit 为 [&quot;apple&quot;, &quot;banana&quot;]的文档db.foods.find({ fruit: [&quot;apple&quot;, &quot;banana&quot;] });// 匹配数组中第一个元素的值// 下面会匹配到 fruit 字段中第一个元素的值是 apple 的文档。db.foods.find({ &quot;fruit.0&quot;: &quot;apple&quot; }); $size $size 对查询字段数组长度很有效。像查询某个字段的数组值只有指定的个数的文档。注意： $size 不能与其他查询条件组合使用。 123// 假设 fruit 的值一个数组// 查询字段 fruit 的个数为 2 个的文档db.foods.find({ fruit: { $size: 2 } }); $slice $slice操作符可以返回某个键匹配数组元素的一个子集。放在 find的第二个参数中。这个操作符不会影响文档其他键的返回。如果指定返回的键，需要显示声明。 123456789// 返回某一个博客的前 10 条评论db.find({ _id: ObjectId(x) }, { comment: { $slice: 10 } });// 返回某一个博客的最后 10 条评论db.find({ _id: ObjectId(x) }, { comment: { $slice: -10 } });// 返回某一个博客的中评论// 跳过前 10 条评论后，取10条db.find({ _id: ObjectId(x) }, { comment: { $slice: [10, 10] } }); $elemMatch 对数组中每一个元素和传入的所有查询条件进行比较。 1234// 假设 x 的值是一个数组// 会对字段 x 进行循环，依次和 $elemMatch 中的条件进行匹配// 只有元素 大于10 并且小于20 才会被命中db.tests.find({ x: { $elemMatch: { $gt: 10, $lt: 20 } } }); 查询内嵌文档 查询内嵌文档有两种方式： 1. 查询整个文档， 2.针对 key/value 进行查询。 精确操作 和 数组的精确查找一样。 内嵌文档的 字段个数、字段顺序、字段名称都需要一致。 key/value 查找 Key/value 查找使用点表示法。当两个查询条件使用了点表示法，他们的关系是 or 的关系。如果需要对两个条件使用 and关系，可以结合 $elemMatch操作符使用。 123456789101112131415// 假设需要查询 有 Joe 发表的 5 分以上的评论// 下面的查询是可能失败的，如果内嵌文档只有这两个字段的时候是OK，// 如果内嵌文档中有额外的字段，就会失败。// 下面的查询是精确匹配db.blogs.find({ comments: { author: &quot;joe&quot;, score: { $gte: 5 } } });// 下面的查询会失败// 下面的查询会匹配到 评论中 author=joe 或者 score &gt;= 5 的文档。db.blogs.find({ &quot;comments.author&quot;: &quot;joe&quot;, &quot;comments.score&quot;: { $gte: 5 } });// 可以使用 $elemMatchdb.blogs.find({ comments: { $elemMatch: { author: &quot;joe&quot;, score: { $gte: 5 } } }}); $where 查询 $where可以在查询中指定任意的 JavaScript。为了安全和性能考虑，应尽可能避免使用。 123456db.foo.find({ $where: function() { // 查询逻辑 // 返回 true 文档就作为结果集的一部分返回，返回false 就不返回 }}); 游标 limit、skip、sort limit在find后使用来限制结果数量，skip和limit结合用于分页查询，指定跳过指定条数。sort用于排序，1 为升序，-1 位降序。 123456// 下面的查询跳过前10条，选择10,以 age 升序排序。db.users .find() .skip(10) .limit(10) .sort({ age: 1 }); 参考mongodb 官方文档 MongoDB 权威指南第二版书籍","link":"/2019/11/12/Mongodb%20find/"},{"title":"TypeScript函数","text":"函数类型和函数定义TypeScript中的函数的定义和JavaScript中定义形式是一样的，无非就是在定义的时候对参数，返回值指定了类型。 函数类型声明 函数类型的格式是 (x: &lt;类型&gt;, y: &lt;类型&gt;) =&gt; &lt;类型&gt; 12345678910111213// 函数声明function add(x: number, y: number): number { return x * y;}// 函数表达式// 这个 add 函数的类型是 (x: number, y: number) =&gt; numberlet add: (x: number, y: number) =&gt; number = function( x: number, y: number): number { return x * y;}; 函数参数函数调用是的传入的参数必须和定义时指定的参数个数和类型都需要保持一致。返回值也是一样。 可选参数在参数名后面添加?代表这个参数是可选的。 123456789101112// 参数lastName是可选的function join(A: string, B?: string): string { if (lastName) { return `${A} ${B}`; } return A;}join(&quot;A&quot;); // Ajoin(&quot;A&quot;, &quot;B&quot;); // A Bjoin(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); // 出错了 传入的参数大于定义的参数 默认参数 可以在函数定义的时候，可以为一些参数设置一些默认值。如果用户没有传递这个参数或则传入 undefined。都会使用这个默认参数。 12345678910function join(A: string, B: string = &quot;default&quot;): string { if (lastName) { return `${A} ${B}`; } return A;}join(&quot;A&quot;); // A defaultjoin(&quot;A&quot;, &quot;B&quot;); // A Bjoin(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); // 出错了 传入的参数大于定义的参数 剩余参数当传入的参数个数不定的时候，可以使用剩余参数处理。他会将这些剩余参数放在数组中。 123function join(A: string, ...rest: Array&lt;string&gt;): string { return `${A} ${rest.join(&quot; &quot;)}`;} 可选参数和剩余参数都必须要放在参数的最后面 函数重载函数重载是TypeScript中的，是使用相同函数名称和不同参数数量和类型创建多个方法的一种能力，函数重载由 重载签名和重载实现组成。 123456789101112131415161718192021222324interface Result { code: number; message: string;}// 重载签名function test(x: Result): Result;function test(x?: number, message?: string): Result;// 重载实现function test(x: Result | number = 200, message: string = &quot;ok&quot;): Result { if (typeof x === &quot;object&quot;) { return x; } return { code: x, message };}console.log(test({ code: 400, message: &quot;bad Request&quot; })); // { code: 400, message: 'bad Request' }console.log(test(401, &quot;未登录&quot;)); // { code: 401, message: '未登录' }console.log(test()); // { code: 200, message: 'ok' } 泛型函数12345678// 声明一个泛型函数// 格式 function 函数名 &lt;T&gt;(参数名: T): Tfunction print&lt;T&gt;(arg: T): T { return arg;}// 使用泛型函数print&lt;string&gt;(&quot;Hello&quot;);","link":"/2019/11/13/TypeScript%E5%87%BD%E6%95%B0/"},{"title":"TypeScript基础类型.md","text":"基础类型 number(数字)number包含整数和小数。可以有二级制，八进制，十进制,十六进制表示法。 1234let num: number = 6; // 十进制let num: number = 0xf00d; // 十六进制let num: number = 0b1010; // 二进制let num: number = 0o744; // 八进制 string(字符串)string类型使用&quot;，'，(`)表示。 123let str: string = &quot;string&quot;;let str: string = &quot;string&quot;;let str: string = `string${foo}`; boolean(布尔)boolean的值只有 true 和 false。 1234let checked: boolean = true;let checked: boolean = false;let checked: boolean = Boolean(true);let checked: boolean = Boolean(false); array(数组)array类型在ts中有两种表示方法。类型定义一种使用数据类型[],另一种使用Array&lt;数据类型&gt;。如果需要在一个数组中有多种不同类型的可以结合联合类型定义。 12let arr: number[] = [1, 2, 3, 4];let arr: Array&lt;number&gt; = [1, 2, 3, 4]; tuple(元组)tuple类型是ts中新增的。表示一个已知元素数量和类型的数组。并且值需要和类型的顺序保存一致。⚡️：元组和数组之间的区别在于: 元组更严格，元素的数量，类型, 顺序,都需要保持一致。 12345let t: [string, number] = [&quot;abc&quot;, 1];// ❌ 案例let t: [string, number] = [1, &quot;abc&quot;]; // 值和类型的定义顺序不对let t: [string, number] = [&quot;1bc&quot;, 1, 2]; // 元素得数量不匹配 enum(枚举)enum类型也是ts中新增的。使用枚举类型可以为一组数值赋予友好的名字。表示一个可以通过key取到value,也可以通过value取到key的对象。 1234567891011// 定义const Colors = { RED, BLUE, YELLOW};// 使用const c: Colors = Colors.RED; // 0const c: Colors = Colors.BLUE; // 1const c: string = Colors[0]; // RED anyany类型表示变量可以是任意类型。ts不会去对这个变量做类型检测。 12345let foo: any = 4;foo = &quot;string&quot;;foo = true;let arr: any[] = [1, &quot;a&quot;, true]; voidvoid表示没有任何类型。它的值只能是 undefined或null。 123456function fn(): void { console.log(1);}let foo: void = null;let foo: void = undefined; null 和 undefinednull和undefined是其他所有类型的子类型。⚡️：null值和undefined值可以赋给其他任何类型。当设置strictNullChecks的时候，只能赋给它们自己和void。 12let u: undefined = undefined;let n: null = null; nevernever表示永远不存在的值的类型，常用于抛出错误，死循环, 返回error()的函数， 1234567891011function err(): never { throw new Error();}function fail(): never { return error(&quot;error&quot;);}function fn(): never { while (true) {}} object(对象)object表示非原始类型。 12345678let obj: object = { number: 12};obj.number = 13; // error 不能修改, 因为 number 属性没有在 object 中声明let obj: { x: number; y: string } = { x: 1, y: &quot;abc&quot; };obj.x = 2; // ok 联合类型对一些值可以是多种类型的变量，需要使用联合类型。 123456789101112131415161718// 基本类型变量let foo: number | string | boolean;foo = 123;foo = &quot;abc&quot;;foo = false;// 函数function fn(value: string | number): void { // ...}fn(1);fn(&quot;abc&quot;);// 泛型和数组let arr: (number | string)[] = [1, &quot;string&quot;];let arr: Array&lt;number | string | boolean&gt;;arr = [1, 1, boolean, &quot;abc&quot;]; 类型别名类型别名是给一组或一个类型起一个名称。他只是引用了别的类型，本身不会创建一个类型。 1234type TypeName = number | string | boolean;let foo: TypeName = 123;let foo: TypeName = &quot;abc&quot;;let foo: TypeName = false; 类型断言当一个变量可以是多个类型的时候。你已经明确知道这个变量的值是某一种类型，使用这个类型上的某个方法的时候，可能会引发ts报错。这时候需要使用类型断言告诉 tsc，我已明确知道了这个类型。请忽略类型检查。 1234let str1: string | number = &quot;123&quot;;// let len: number = str1.length; // errorlet len: number = (str1 as string).length; // 方法1let len: number = (&lt;string&gt;str1).length; // 方法2 不能再jsx 中使用","link":"/2019/09/17/TypeScript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"TypsScript","slug":"TypsScript","link":"/tags/TypsScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Mongodb","slug":"Mongodb","link":"/tags/Mongodb/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"}],"categories":[]}